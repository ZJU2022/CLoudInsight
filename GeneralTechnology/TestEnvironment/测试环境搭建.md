# 测试环境搭建与维护完整指南

## 概述

本文档详细介绍了从零开始搭建和维护测试环境的完整流程，包括机房迁移运维基础知识、Kubernetes部署、服务配置、CI/CD流水线构建以及自动化测试实施。

## 第一步：了解机房迁移运维基础知识（申请机器）

### 1.1 物理机申请与配置

#### 申请物理机时需要明确的信息：
- **硬件配置需求**：
  - CPU：核心数和性能要求
  - 内存：64G（共享，非独占）
  - 存储：960GB SSD
  - 网络：带宽要求

#### 常见配置示例：
```
A: 你们那边物理机需要多大的盘，大概占用多少内存，几个副本。
B: 64G 3 960SSD
A: 单服务 64G？要独占吗？
B: 不用独占，共享就OK
B: mysql 和 redis 还有kafka 用的机器就可以了,配置看着给
```

### 1.2 物理机基础知识

#### 硬件构成：
- **CPU（中央处理器）**：负责执行计算机程序的中央处理器
- **内存（RAM）**：用于存储正在运行的程序和数据的临时存储器
- **硬盘**：用于长期存储数据的设备（HDD/SSD）
- **网络适配器**：用于连接服务器到网络的网络接口卡
- **电源供应**：用于提供服务器所需的电能

#### 重要概念：
- **物理服务器**：实际的硬件服务器，位于数据中心或机房
- **远程访问**：通过SSH、RDP等协议进行远程管理
- **资源分配**：CPU、内存、硬盘空间等资源的规划分配
- **扩展性**：通过添加更多物理服务器或升级硬件来扩展

### 1.3 网络基础知识

#### 核心概念：
- **TCP/IP协议栈**
- **IP地址、子网掩码、广播地址**
- **网关、DNS服务器**
- **路由表、端口、进程**

#### 常见网络问题排查：
```bash
# 网络连通性测试
ping <target_ip>
telnet <host> <port>
curl <url>
iperf -c <server_ip>  # 带宽测试

# 网络配置查看
ip addr show
ip route show
cat /etc/resolv.conf
```

### 1.4 Linux系统基础

#### 文件系统管理：
```bash
# 磁盘使用情况查看
df -h
du -sh /path/to/directory

# 磁盘配额管理
# - 用户配额：限制/home目录下用户可用容量
# - 子卷配额：限制子卷单元可用容量
# - 目录配额：限制特定目录可用容量
```

#### 内存管理：
```bash
# 内存使用情况查看
free -h

# 内存分配方式：
# - 内核使用的内存（不可释放）
# - 进程使用的内存
# - 可用内存（空闲内存）
```

## 第二步：裸机上部署Kubernetes

### 2.1 环境准备

#### 系统要求：
- **操作系统**：Ubuntu 20.04+ / CentOS 7+
- **硬件要求**：
  - CPU：2核心以上
  - 内存：2GB以上
  - 磁盘：20GB以上可用空间

#### 网络要求：
- 所有节点间网络互通
- 关闭防火墙或开放必要端口
- 禁用swap分区

### 2.2 安装步骤

#### 1. 安装Docker
```bash
# 安装Docker
curl -fsSL https://get.docker.com | bash
systemctl enable docker
systemctl start docker

# 配置Docker镜像加速
cat > /etc/docker/daemon.json << EOF
{
  "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]
}
EOF
systemctl restart docker
```

#### 2. 安装Kubernetes组件
```bash
# 添加Kubernetes源
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" > /etc/apt/sources.list.d/kubernetes.list

# 安装kubeadm、kubelet、kubectl
apt-get update
apt-get install -y kubelet kubeadm kubectl
```

#### 3. 初始化集群
```bash
# 主节点初始化
kubeadm init --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=<MASTER_IP>

# 配置kubectl
mkdir -p $HOME/.kube
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config

# 安装网络插件（以Flannel为例）
kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
```

#### 4. 添加工作节点
```bash
# 在工作节点上执行（使用主节点初始化时提供的join命令）
kubeadm join <MASTER_IP>:6443 --token <TOKEN> --discovery-token-ca-cert-hash <HASH>
```

### 2.3 验证部署
```bash
# 检查节点状态
kubectl get nodes

# 检查系统Pod状态
kubectl get pods --all-namespaces

# 检查集群信息
kubectl cluster-info
```

## 第三步：根据配置文件在Kubernetes环境中起服务

### 3.1 配置文件管理

#### 配置文件结构：
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  namespace: test
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: my-app:latest
        ports:
        - containerPort: 8080
```

```yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
  namespace: test
spec:
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
```

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
  namespace: test
spec:
  rules:
  - host: my-app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: my-app-service
            port:
              number: 80
```

### 3.2 部署服务

#### 1. 创建命名空间
```bash
kubectl create namespace test
```

#### 2. 应用配置文件
```bash
# 应用所有配置文件
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
kubectl apply -f ingress.yaml

# 或者应用整个目录
kubectl apply -f ./k8s-configs/
```

#### 3. 验证部署
```bash
# 检查Pod状态
kubectl get pods -n test

# 检查Service状态
kubectl get services -n test

# 检查Ingress状态
kubectl get ingress -n test

# 查看Pod日志
kubectl logs <pod-name> -n test

# 查看Pod详细信息
kubectl describe pod <pod-name> -n test
```

### 3.3 常见问题排查

#### 1. Service无法找到Endpoint
**问题**：Service有selector `app=express`，Pod也打上了label `app=express`，但Service不生效

**解决方案**：
```bash
# 检查Pod的标签
kubectl get pods --show-labels -n test

# 检查Service的selector
kubectl describe service <service-name> -n test

# 确保标签完全匹配
kubectl label pod <pod-name> app=express -n test
```

#### 2. 配置文件更新
```bash
# 编辑配置文件
kubectl edit deployment <deployment-name> -n test

# 或者重新应用配置文件
kubectl apply -f updated-deployment.yaml

# 强制重新部署
kubectl rollout restart deployment <deployment-name> -n test
```

## 第四步：Jenkins CI/CD添加Build和Deploy工作流

### 4.1 Jenkins环境搭建

#### 1. 安装Jenkins
```bash
# 使用Docker安装Jenkins
docker run -d \
  --name jenkins \
  -p 8080:8080 \
  -p 50000:50000 \
  -v jenkins_home:/var/jenkins_home \
  jenkins/jenkins:lts
```

#### 2. 安装必要插件
- **Pipeline插件**：支持Jenkinsfile
- **Kubernetes插件**：支持K8s部署
- **Git插件**：支持代码拉取
- **Docker插件**：支持镜像构建

### 4.2 构建节点配置

#### 1. 创建构建节点
```bash
# 在构建节点上安装必要工具
# Node.js
curl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -
apt-get install -y nodejs

# Go
wget https://golang.org/dl/go1.19.linux-amd64.tar.gz
tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

# Docker
curl -fsSL https://get.docker.com | bash

# Kubernetes工具
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl
mv kubectl /usr/local/bin/
```

#### 2. 配置Jenkins节点
- 在Jenkins管理页面添加节点
- 配置SSH连接信息
- 设置节点标签（如：build-node）

### 4.3 工作流配置

#### 1. 构建工作流（Jenkinsfile）
```groovy
pipeline {
    agent {
        label 'build-node'
    }
    
    environment {
        DOCKER_IMAGE = 'my-app'
        DOCKER_TAG = "${env.BUILD_NUMBER}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Build') {
            steps {
                sh 'npm install'
                sh 'npm run build'
            }
        }
        
        stage('Test') {
            steps {
                sh 'npm test'
            }
        }
        
        stage('Docker Build') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} ."
                sh "docker push ${DOCKER_IMAGE}:${DOCKER_TAG}"
            }
        }
        
        stage('Deploy to K8s') {
            steps {
                sh "kubectl set image deployment/my-app my-app=${DOCKER_IMAGE}:${DOCKER_TAG} -n test"
                sh "kubectl rollout status deployment/my-app -n test"
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
    }
}
```

#### 2. 发布推包工作流
```groovy
pipeline {
    agent any
    
    parameters {
        string(name: 'VERSION', defaultValue: '', description: '发布版本号')
        choice(name: 'ENVIRONMENT', choices: ['dev', 'test', 'prod'], description: '目标环境')
    }
    
    stages {
        stage('Package') {
            steps {
                sh "docker tag my-app:latest my-app:${params.VERSION}"
                sh "docker push my-app:${params.VERSION}"
            }
        }
        
        stage('Deploy') {
            steps {
                sh "kubectl set image deployment/my-app my-app=my-app:${params.VERSION} -n ${params.ENVIRONMENT}"
            }
        }
    }
}
```

#### 3. 回归测试工作流
```groovy
pipeline {
    agent any
    
    stages {
        stage('Run Tests') {
            steps {
                sh 'npm run test:regression'
            }
        }
        
        stage('Generate Report') {
            steps {
                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: 'test-results',
                    reportFiles: 'index.html',
                    reportName: 'Test Report'
                ])
            }
        }
    }
}
```

### 4.4 视图管理

#### 创建项目视图：
- 在Jenkins中创建新的View
- 配置View类型为"List View"
- 添加项目过滤器，将相关项目加入该View
- 便于项目管理和展示

## 第五步：熟悉Jenkins工作流节点的底层逻辑

### 5.1 Jenkins架构理解

#### 核心组件：
- **Jenkins Master**：中央协调器，负责任务调度
- **Jenkins Agent/Node**：执行节点，实际执行构建任务
- **Pipeline**：流水线定义，描述构建流程
- **Stage**：流水线阶段，逻辑分组
- **Step**：具体执行步骤

### 5.2 工作流执行机制

#### 1. 任务调度
```groovy
// 指定执行节点
agent {
    label 'build-node'  // 在指定标签的节点上执行
}

// 动态分配
agent any  // 在任何可用节点上执行
```

#### 2. 环境变量管理
```groovy
environment {
    // 定义环境变量
    APP_NAME = 'my-app'
    VERSION = '1.0.0'
}

stages {
    stage('Build') {
        environment {
            // 阶段级环境变量
            BUILD_TYPE = 'release'
        }
        steps {
            echo "Building ${APP_NAME} version ${VERSION}"
        }
    }
}
```

#### 3. 条件执行
```groovy
stages {
    stage('Deploy to Test') {
        when {
            branch 'develop'
        }
        steps {
            sh 'deploy-to-test.sh'
        }
    }
    
    stage('Deploy to Prod') {
        when {
            branch 'main'
        }
        steps {
            input message: 'Deploy to production?'
            sh 'deploy-to-prod.sh'
        }
    }
}
```

### 5.3 错误处理和恢复

#### 1. 重试机制
```groovy
stages {
    stage('Deploy') {
        steps {
            retry(3) {
                sh 'kubectl apply -f k8s/'
            }
        }
    }
}
```

#### 2. 超时控制
```groovy
stages {
    stage('Build') {
        options {
            timeout(time: 30, unit: 'MINUTES')
        }
        steps {
            sh 'npm run build'
        }
    }
}
```

#### 3. 清理操作
```groovy
post {
    always {
        // 总是执行清理
        cleanWs()
    }
    success {
        // 成功时执行
        echo 'Build successful!'
    }
    failure {
        // 失败时执行
        echo 'Build failed!'
        emailext subject: 'Build Failed',
                 body: 'Build failed, please check Jenkins',
                 to: 'team@company.com'
    }
}
```

## 第六步：从0到1构建自动化测试

### 6.1 测试策略规划

#### 测试金字塔：
```
    /\
   /  \    E2E Tests (少量)
  /____\   
 /      \  Integration Tests (中等)
/________\ Unit Tests (大量)
```

#### 测试类型：
- **单元测试**：测试单个函数或组件
- **集成测试**：测试组件间交互
- **端到端测试**：测试完整用户流程
- **性能测试**：测试系统性能指标

### 6.2 测试框架选择

#### 前端测试：
```javascript
// Jest + React Testing Library
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from './App';

test('renders login form', () => {
  render(<App />);
  expect(screen.getByText(/login/i)).toBeInTheDocument();
});
```

#### 后端测试：
```go
// Go testing + testify
package main

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestUserService_CreateUser(t *testing.T) {
    service := NewUserService()
    user, err := service.CreateUser("test@example.com", "password")
    
    assert.NoError(t, err)
    assert.NotNil(t, user)
    assert.Equal(t, "test@example.com", user.Email)
}
```

### 6.3 测试数据管理

#### 1. 测试数据库
```yaml
# docker-compose.test.yml
version: '3.8'
services:
  test-db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: test
      MYSQL_DATABASE: test_db
    ports:
      - "3307:3306"
```

#### 2. 测试数据准备
```javascript
// 测试数据工厂
class UserFactory {
    static create(overrides = {}) {
        return {
            id: 1,
            email: 'test@example.com',
            name: 'Test User',
            ...overrides
        };
    }
}
```

### 6.4 自动化测试流水线

#### 1. 单元测试流水线
```groovy
stage('Unit Tests') {
    parallel {
        stage('Frontend Tests') {
            steps {
                dir('frontend') {
                    sh 'npm test -- --coverage'
                }
            }
        }
        stage('Backend Tests') {
            steps {
                dir('backend') {
                    sh 'go test ./... -v -cover'
                }
            }
        }
    }
}
```

#### 2. 集成测试流水线
```groovy
stage('Integration Tests') {
    steps {
        sh 'docker-compose -f docker-compose.test.yml up -d'
        sh 'npm run test:integration'
        sh 'docker-compose -f docker-compose.test.yml down'
    }
}
```

#### 3. 端到端测试流水线
```groovy
stage('E2E Tests') {
    steps {
        sh 'npm run test:e2e'
    }
    post {
        always {
            publishHTML([
                allowMissing: false,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: 'e2e-results',
                reportFiles: 'index.html',
                reportName: 'E2E Test Report'
            ])
        }
    }
}
```

## 第七步：构建单测

### 7.1 单元测试最佳实践

#### 1. 测试结构（AAA模式）
```javascript
describe('UserService', () => {
    describe('createUser', () => {
        it('should create user successfully', () => {
            // Arrange - 准备测试数据
            const userData = { email: 'test@example.com', password: 'password' };
            const mockRepo = { save: jest.fn().mockResolvedValue({ id: 1, ...userData }) };
            const service = new UserService(mockRepo);
            
            // Act - 执行被测试的方法
            const result = await service.createUser(userData);
            
            // Assert - 验证结果
            expect(result).toEqual({ id: 1, ...userData });
            expect(mockRepo.save).toHaveBeenCalledWith(userData);
        });
    });
});
```

#### 2. 测试覆盖率要求
```javascript
// jest.config.js
module.exports = {
    collectCoverageFrom: [
        'src/**/*.{js,jsx,ts,tsx}',
        '!src/**/*.d.ts',
        '!src/index.tsx',
    ],
    coverageThreshold: {
        global: {
            branches: 80,
            functions: 80,
            lines: 80,
            statements: 80,
        },
    },
};
```

### 7.2 CI/CD集成单测

#### 1. Travis CI配置
```yaml
# .travis.yml
language: go
go:
  - "1.18"

services:
  - mysql

install:
  - cd $TRAVIS_BUILD_DIR
  - export GOPRIVATE=github.com/qbox/*
  - export QVM_RIO_READ_DIR=./mock/
  - git config --global url."git@github.com:".insteadOf "https://github.com/"

before_script:
  - mysql -u root -e 'CREATE DATABASE IF NOT EXISTS rio_test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;'

script:
  - go env -w GOPRIVATE=github.com/qbox/*
  - go mod download
  - go install ./...
  - CGO_ENABLED=0 go test -v $(go list ./...)
```

#### 2. Jenkins单测流水线
```groovy
stage('Unit Tests') {
    parallel {
        stage('Go Tests') {
            steps {
                sh 'go test -v -coverprofile=coverage.out ./...'
                sh 'go tool cover -html=coverage.out -o coverage.html'
            }
            post {
                always {
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: '.',
                        reportFiles: 'coverage.html',
                        reportName: 'Go Coverage Report'
                    ])
                }
            }
        }
        
        stage('JavaScript Tests') {
            steps {
                sh 'npm test -- --coverage --watchAll=false'
            }
            post {
                always {
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'coverage/lcov-report',
                        reportFiles: 'index.html',
                        reportName: 'JS Coverage Report'
                    ])
                }
            }
        }
    }
}
```

### 7.3 测试质量保证

#### 1. 代码质量检查
```groovy
stage('Code Quality') {
    steps {
        sh 'npm run lint'
        sh 'go vet ./...'
        sh 'golangci-lint run'
    }
}
```

#### 2. 安全扫描
```groovy
stage('Security Scan') {
    steps {
        sh 'npm audit'
        sh 'gosec ./...'
    }
}
```

#### 3. 性能测试
```groovy
stage('Performance Tests') {
    steps {
        sh 'npm run test:performance'
    }
}
```

## 总结

通过以上七个步骤，我们可以构建一个完整的测试环境：

1. **基础设施准备**：了解物理机申请和网络配置
2. **容器编排**：部署Kubernetes集群
3. **服务部署**：使用配置文件部署应用服务
4. **CI/CD流水线**：构建自动化构建和部署流程
5. **底层机制**：深入理解Jenkins工作流执行原理
6. **自动化测试**：构建完整的测试体系
7. **质量保证**：通过单测确保代码质量

这个流程确保了测试环境的稳定性、可维护性和可扩展性，为持续集成和持续部署提供了坚实的基础。

## 参考资料

- [Linux是怎样工作的](https://leetcode.cn/leetbook/detail/how-does-linux-work/)
- [Kubernetes官方文档](https://kubernetes.io/docs/)
- [Jenkins官方文档](https://www.jenkins.io/doc/)
- [Docker官方文档](https://docs.docker.com/)
- [Travis CI官方教程](https://docs.travis-ci.com/)
