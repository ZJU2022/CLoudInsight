# 测试环境日常维护实践案例

## 项目背景

本文档以一个实际的电商平台测试环境为例，详细说明测试环境的日常维护工作。该测试环境用于支持开发团队的持续集成测试、QA团队的回归测试以及产品团队的验收测试。

## 环境架构

### 硬件配置

#### 三台物理机器配置：

**机器1：应用服务器（app-server-01）**
- **CPU**：Intel Xeon E5-2680 v4，16核心32线程
- **内存**：64GB DDR4
- **存储**：960GB SSD（系统盘）+ 2TB HDD（数据盘）
- **网络**：双千兆网卡
- **用途**：运行主应用服务、API网关、负载均衡器

**机器2：数据库服务器（db-server-01）**
- **CPU**：Intel Xeon E5-2680 v4，16核心32线程
- **内存**：128GB DDR4（数据库需要更多内存）
- **存储**：960GB SSD（系统盘）+ 4TB SSD（数据库专用）
- **网络**：双千兆网卡
- **用途**：MySQL主从集群、Redis集群、MongoDB

**机器3：监控服务器（monitor-server-01）**
- **CPU**：Intel Xeon E5-2680 v4，8核心16线程
- **内存**：32GB DDR4
- **存储**：960GB SSD（系统盘）+ 1TB HDD（日志存储）
- **网络**：双千兆网卡
- **用途**：Prometheus监控、Grafana可视化、ELK日志分析

### 网络架构

#### 网络拓扑：
```
Internet
    |
    v
[负载均衡器] (app-server-01:80)
    |
    v
[应用集群] (app-server-01:8080-8090)
    |
    v
[数据库集群] (db-server-01:3306,6379,27017)
    |
    v
[监控系统] (monitor-server-01:9090,3000,9200)
```

#### 网络配置：
```bash
# 内网网段配置
内网网段：192.168.1.0/24
app-server-01: 192.168.1.10
db-server-01: 192.168.1.20
monitor-server-01: 192.168.1.30

# 外网访问
外网IP：通过NAT映射
app-server-01: 公网IP -> 192.168.1.10:80
```

#### 防火墙规则：
```bash
# 允许的端口
80, 443 (HTTP/HTTPS)
22 (SSH)
3306 (MySQL)
6379 (Redis)
27017 (MongoDB)
9090 (Prometheus)
3000 (Grafana)
9200 (Elasticsearch)
```

## 日常维护工作

### 1. 系统监控

#### 1.1 资源监控脚本
```bash
#!/bin/bash
# 文件名：monitor_resources.sh
# 用途：监控系统资源使用情况

LOG_FILE="/var/log/system_monitor.log"
ALERT_THRESHOLD=80

# 检查CPU使用率
check_cpu() {
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    if (( $(echo "$cpu_usage > $ALERT_THRESHOLD" | bc -l) )); then
        echo "$(date): CPU使用率过高: ${cpu_usage}%" >> $LOG_FILE
        send_alert "CPU使用率过高: ${cpu_usage}%"
    fi
}

# 检查内存使用率
check_memory() {
    memory_usage=$(free | grep Mem | awk '{printf("%.2f", $3/$2 * 100.0)}')
    if (( $(echo "$memory_usage > $ALERT_THRESHOLD" | bc -l) )); then
        echo "$(date): 内存使用率过高: ${memory_usage}%" >> $LOG_FILE
        send_alert "内存使用率过高: ${memory_usage}%"
    fi
}

# 检查磁盘使用率
check_disk() {
    disk_usage=$(df / | tail -1 | awk '{print $5}' | cut -d'%' -f1)
    if [ $disk_usage -gt $ALERT_THRESHOLD ]; then
        echo "$(date): 磁盘使用率过高: ${disk_usage}%" >> $LOG_FILE
        send_alert "磁盘使用率过高: ${disk_usage}%"
    fi
}

# 发送告警
send_alert() {
    message="$1"
    # 发送邮件告警
    echo "$message" | mail -s "系统告警" admin@company.com
    # 发送钉钉告警
    curl -X POST "https://oapi.dingtalk.com/robot/send?access_token=YOUR_TOKEN" \
         -H "Content-Type: application/json" \
         -d "{\"text\":\"$message\"}"
}

# 主函数
main() {
    check_cpu
    check_memory
    check_disk
}

main
```

#### 1.2 服务状态监控
```bash
#!/bin/bash
# 文件名：service_monitor.sh
# 用途：监控关键服务状态

SERVICES=("nginx" "mysql" "redis" "mongod" "prometheus" "grafana")

check_service() {
    local service=$1
    if ! systemctl is-active --quiet $service; then
        echo "$(date): 服务 $service 已停止" >> /var/log/service_monitor.log
        systemctl restart $service
        send_alert "服务 $service 已重启"
    fi
}

for service in "${SERVICES[@]}"; do
    check_service $service
done
```

### 2. 数据库维护

#### 2.1 数据库备份脚本
```bash
#!/bin/bash
# 文件名：db_backup.sh
# 用途：自动备份数据库

BACKUP_DIR="/backup/database"
DATE=$(date +%Y%m%d_%H%M%S)
RETENTION_DAYS=7

# MySQL备份
backup_mysql() {
    echo "开始备份MySQL..."
    mysqldump --all-databases --single-transaction --routines --triggers \
        --user=root --password=YOUR_PASSWORD > $BACKUP_DIR/mysql_$DATE.sql
    gzip $BACKUP_DIR/mysql_$DATE.sql
}

# Redis备份
backup_redis() {
    echo "开始备份Redis..."
    redis-cli BGSAVE
    cp /var/lib/redis/dump.rdb $BACKUP_DIR/redis_$DATE.rdb
}

# MongoDB备份
backup_mongodb() {
    echo "开始备份MongoDB..."
    mongodump --out $BACKUP_DIR/mongodb_$DATE
    tar -czf $BACKUP_DIR/mongodb_$DATE.tar.gz -C $BACKUP_DIR mongodb_$DATE
    rm -rf $BACKUP_DIR/mongodb_$DATE
}

# 清理旧备份
cleanup_old_backups() {
    find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
    find $BACKUP_DIR -name "*.rdb" -mtime +$RETENTION_DAYS -delete
    find $BACKUP_DIR -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete
}

# 主函数
main() {
    mkdir -p $BACKUP_DIR
    backup_mysql
    backup_redis
    backup_mongodb
    cleanup_old_backups
    echo "数据库备份完成: $DATE"
}

main
```

#### 2.2 数据库性能优化
```bash
#!/bin/bash
# 文件名：db_optimize.sh
# 用途：数据库性能优化

# MySQL优化
optimize_mysql() {
    echo "优化MySQL..."
    mysql -u root -pYOUR_PASSWORD -e "
        OPTIMIZE TABLE user_profile, order_info, product_catalog;
        ANALYZE TABLE user_profile, order_info, product_catalog;
    "
}

# Redis优化
optimize_redis() {
    echo "优化Redis..."
    redis-cli FLUSHDB
    redis-cli BGSAVE
}

# MongoDB优化
optimize_mongodb() {
    echo "优化MongoDB..."
    mongo --eval "db.runCommand({compact: 'users'})"
    mongo --eval "db.runCommand({compact: 'orders'})"
}
```

### 3. 日志管理

#### 3.1 日志轮转配置
```bash
# /etc/logrotate.d/app_logs
/var/log/app/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 644 app app
    postrotate
        systemctl reload nginx
    endscript
}
```

#### 3.2 日志分析脚本
```bash
#!/bin/bash
# 文件名：log_analyzer.sh
# 用途：分析应用日志

LOG_DIR="/var/log/app"
REPORT_FILE="/var/log/analysis_report.txt"

analyze_errors() {
    echo "=== 错误日志分析 ===" > $REPORT_FILE
    echo "时间范围: $(date -d '1 day ago' +%Y-%m-%d) 到 $(date +%Y-%m-%d)" >> $REPORT_FILE
    
    # 统计错误类型
    echo "错误类型统计:" >> $REPORT_FILE
    grep -r "ERROR" $LOG_DIR | awk '{print $4}' | sort | uniq -c | sort -nr >> $REPORT_FILE
    
    # 统计最频繁的错误
    echo "最频繁的错误:" >> $REPORT_FILE
    grep -r "ERROR" $LOG_DIR | head -10 >> $REPORT_FILE
}

analyze_performance() {
    echo "=== 性能分析 ===" >> $REPORT_FILE
    # 分析响应时间
    echo "平均响应时间:" >> $REPORT_FILE
    grep "response_time" $LOG_DIR/*.log | awk '{sum+=$NF; count++} END {print sum/count "ms"}' >> $REPORT_FILE
}

main() {
    analyze_errors
    analyze_performance
    echo "日志分析完成，报告保存在: $REPORT_FILE"
}

main
```

## 常见问题及解决方案

### 1. 网络连接问题

#### 问题1：机器间网络不通
**症状**：应用服务器无法连接数据库服务器
**排查步骤**：
```bash
# 1. 检查网络连通性
ping 192.168.1.20

# 2. 检查端口是否开放
telnet 192.168.1.20 3306

# 3. 检查防火墙规则
iptables -L -n

# 4. 检查路由表
ip route show
```

**解决方案**：
```bash
# 开放数据库端口
iptables -A INPUT -p tcp --dport 3306 -j ACCEPT
iptables -A INPUT -p tcp --dport 6379 -j ACCEPT
iptables -A INPUT -p tcp --dport 27017 -j ACCEPT

# 保存防火墙规则
iptables-save > /etc/iptables/rules.v4
```

#### 问题2：外网访问异常
**症状**：外部用户无法访问测试环境
**排查步骤**：
```bash
# 1. 检查NAT映射
iptables -t nat -L -n

# 2. 检查负载均衡器状态
systemctl status nginx

# 3. 检查SSL证书
openssl x509 -in /etc/ssl/certs/app.crt -text -noout
```

**解决方案**：
```bash
# 重新配置NAT映射
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.1.10:80
iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to-destination 192.168.1.10:443

# 重启负载均衡器
systemctl restart nginx
```

### 2. 性能问题

#### 问题1：CPU使用率过高
**症状**：CPU使用率持续超过80%
**排查步骤**：
```bash
# 1. 查看CPU使用情况
top -p 1

# 2. 查看进程详情
ps aux --sort=-%cpu | head -10

# 3. 查看系统负载
uptime

# 4. 查看I/O等待
iostat -x 1 5
```

**解决方案**：
```bash
# 1. 优化数据库查询
mysql -u root -p -e "SHOW PROCESSLIST;"

# 2. 调整应用配置
sed -i 's/max_connections = 100/max_connections = 200/' /etc/mysql/mysql.conf.d/mysqld.cnf

# 3. 重启服务
systemctl restart mysql
systemctl restart nginx
```

#### 问题2：内存不足
**症状**：系统频繁使用swap，应用响应缓慢
**排查步骤**：
```bash
# 1. 查看内存使用情况
free -h

# 2. 查看内存占用最多的进程
ps aux --sort=-%mem | head -10

# 3. 查看swap使用情况
swapon -s
```

**解决方案**：
```bash
# 1. 清理缓存
sync && echo 3 > /proc/sys/vm/drop_caches

# 2. 调整MySQL内存配置
sed -i 's/innodb_buffer_pool_size = 1G/innodb_buffer_pool_size = 4G/' /etc/mysql/mysql.conf.d/mysqld.cnf

# 3. 重启MySQL
systemctl restart mysql
```

### 3. 磁盘空间问题

#### 问题1：磁盘空间不足
**症状**：磁盘使用率超过90%
**排查步骤**：
```bash
# 1. 查看磁盘使用情况
df -h

# 2. 查看大文件
find / -type f -size +100M -exec ls -lh {} \;

# 3. 查看目录大小
du -sh /* | sort -hr
```

**解决方案**：
```bash
# 1. 清理日志文件
find /var/log -name "*.log" -mtime +7 -delete

# 2. 清理临时文件
rm -rf /tmp/*

# 3. 清理Docker镜像
docker system prune -a

# 4. 清理备份文件
find /backup -name "*.tar.gz" -mtime +30 -delete
```

## 自动化维护脚本

### 1. 环境健康检查脚本
```bash
#!/bin/bash
# 文件名：health_check.sh
# 用途：全面检查环境健康状态

REPORT_FILE="/var/log/health_check_$(date +%Y%m%d).log"

check_system_health() {
    echo "=== 系统健康检查 ===" | tee -a $REPORT_FILE
    
    # CPU检查
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    echo "CPU使用率: ${cpu_usage}%" | tee -a $REPORT_FILE
    
    # 内存检查
    memory_usage=$(free | grep Mem | awk '{printf("%.2f", $3/$2 * 100.0)}')
    echo "内存使用率: ${memory_usage}%" | tee -a $REPORT_FILE
    
    # 磁盘检查
    disk_usage=$(df / | tail -1 | awk '{print $5}' | cut -d'%' -f1)
    echo "磁盘使用率: ${disk_usage}%" | tee -a $REPORT_FILE
    
    # 网络检查
    echo "网络连通性检查:" | tee -a $REPORT_FILE
    ping -c 3 192.168.1.20 >> $REPORT_FILE 2>&1
}

check_service_health() {
    echo "=== 服务健康检查 ===" | tee -a $REPORT_FILE
    
    services=("nginx" "mysql" "redis" "mongod" "prometheus" "grafana")
    
    for service in "${services[@]}"; do
        if systemctl is-active --quiet $service; then
            echo "$service: 运行中" | tee -a $REPORT_FILE
        else
            echo "$service: 已停止" | tee -a $REPORT_FILE
        fi
    done
}

check_database_health() {
    echo "=== 数据库健康检查 ===" | tee -a $REPORT_FILE
    
    # MySQL检查
    if mysql -u root -pYOUR_PASSWORD -e "SELECT 1;" > /dev/null 2>&1; then
        echo "MySQL: 连接正常" | tee -a $REPORT_FILE
    else
        echo "MySQL: 连接异常" | tee -a $REPORT_FILE
    fi
    
    # Redis检查
    if redis-cli ping > /dev/null 2>&1; then
        echo "Redis: 连接正常" | tee -a $REPORT_FILE
    else
        echo "Redis: 连接异常" | tee -a $REPORT_FILE
    fi
}

main() {
    check_system_health
    check_service_health
    check_database_health
    echo "健康检查完成，报告保存在: $REPORT_FILE"
}

main
```

### 2. 自动清理脚本
```bash
#!/bin/bash
# 文件名：auto_cleanup.sh
# 用途：自动清理系统垃圾文件

# 清理日志文件
cleanup_logs() {
    echo "清理日志文件..."
    find /var/log -name "*.log" -mtime +7 -delete
    find /var/log -name "*.gz" -mtime +30 -delete
}

# 清理临时文件
cleanup_temp() {
    echo "清理临时文件..."
    rm -rf /tmp/*
    rm -rf /var/tmp/*
}

# 清理Docker资源
cleanup_docker() {
    echo "清理Docker资源..."
    docker system prune -f
    docker image prune -f
}

# 清理备份文件
cleanup_backups() {
    echo "清理备份文件..."
    find /backup -name "*.tar.gz" -mtime +30 -delete
    find /backup -name "*.sql.gz" -mtime +7 -delete
}

main() {
    cleanup_logs
    cleanup_temp
    cleanup_docker
    cleanup_backups
    echo "自动清理完成"
}

main
```

### 3. 定时任务配置
```bash
# /etc/crontab 配置
# 每天凌晨2点进行数据库备份
0 2 * * * root /usr/local/scripts/db_backup.sh

# 每小时检查系统健康状态
0 * * * * root /usr/local/scripts/health_check.sh

# 每天凌晨3点进行自动清理
0 3 * * * root /usr/local/scripts/auto_cleanup.sh

# 每5分钟检查服务状态
*/5 * * * * root /usr/local/scripts/service_monitor.sh

# 每周日凌晨进行系统优化
0 4 * * 0 root /usr/local/scripts/db_optimize.sh
```

## 人员需求与职责分工

### 1. 运维工程师（1-2人）

#### 主要职责：
- **系统维护**：操作系统更新、安全补丁安装
- **网络管理**：网络配置、防火墙规则维护
- **监控管理**：Prometheus、Grafana配置和维护
- **备份管理**：数据库备份、系统备份
- **故障处理**：系统故障排查和修复

#### 技能要求：
- Linux系统管理
- 网络配置和故障排查
- 数据库管理（MySQL、Redis、MongoDB）
- 监控工具使用（Prometheus、Grafana）
- Shell脚本编写

### 2. 开发工程师（3-5人）

#### 主要职责：
- **应用部署**：代码部署、版本管理
- **配置管理**：应用配置文件维护
- **日志分析**：应用日志查看和分析
- **性能优化**：应用性能调优
- **问题排查**：应用相关问题排查

#### 技能要求：
- 容器技术（Docker、Kubernetes）
- CI/CD工具使用（Jenkins、GitLab CI）
- 应用性能分析
- 日志分析工具

### 3. 测试工程师（2-3人）

#### 主要职责：
- **测试环境验证**：验证环境可用性
- **测试数据管理**：测试数据准备和维护
- **自动化测试**：编写和执行自动化测试
- **问题报告**：环境问题记录和报告
- **测试报告**：测试结果分析和报告

#### 技能要求：
- 自动化测试框架
- 测试数据管理
- 测试环境配置
- 问题分析和报告

### 4. 项目经理（1人）

#### 主要职责：
- **资源协调**：协调各团队资源
- **进度管理**：项目进度跟踪
- **需求管理**：收集和管理环境需求
- **风险管理**：识别和应对环境风险
- **沟通协调**：团队间沟通协调

#### 技能要求：
- 项目管理
- 团队协作
- 技术理解
- 沟通能力

## 维护流程

### 1. 日常维护流程

#### 每日工作：
1. **晨检**（9:00-9:30）
   - 检查系统健康状态
   - 查看告警信息
   - 确认服务运行状态

2. **监控**（全天）
   - 实时监控系统资源
   - 处理告警信息
   - 记录异常情况

3. **维护**（14:00-16:00）
   - 执行日常维护任务
   - 更新系统配置
   - 清理临时文件

4. **总结**（17:30-18:00）
   - 记录当日工作内容
   - 更新维护日志
   - 计划次日工作

#### 每周工作：
1. **系统优化**（周一）
   - 数据库优化
   - 系统性能调优
   - 安全更新

2. **备份验证**（周二）
   - 验证备份完整性
   - 测试恢复流程
   - 更新备份策略

3. **安全检查**（周三）
   - 安全漏洞扫描
   - 权限检查
   - 安全配置更新

4. **性能分析**（周四）
   - 性能数据分析
   - 瓶颈识别
   - 优化建议

5. **文档更新**（周五）
   - 更新维护文档
   - 记录问题解决方案
   - 整理最佳实践

### 2. 应急响应流程

#### 故障分级：
- **P1**：系统完全不可用，影响所有用户
- **P2**：主要功能不可用，影响大部分用户
- **P3**：部分功能不可用，影响部分用户
- **P4**：功能异常，但不影响正常使用

#### 响应流程：
1. **故障发现**：监控告警或用户报告
2. **故障确认**：确认故障范围和影响
3. **故障分级**：根据影响程度确定优先级
4. **故障处理**：按照预案进行处理
5. **故障恢复**：验证系统恢复正常
6. **故障总结**：分析原因，制定改进措施

## 总结

通过以上详细的维护实践案例，我们可以看到测试环境的日常维护是一个系统性的工作，需要：

1. **完善的监控体系**：实时监控系统状态，及时发现问题
2. **自动化脚本**：减少重复性工作，提高维护效率
3. **标准化流程**：确保维护工作的规范性和一致性
4. **团队协作**：不同角色的人员各司其职，共同维护环境稳定
5. **持续改进**：根据实际情况不断优化维护流程和工具

这样的维护体系能够确保测试环境的稳定性和可用性，为开发和测试工作提供可靠的基础支撑。